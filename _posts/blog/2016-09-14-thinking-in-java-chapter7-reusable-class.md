---
layout: post
title: 复用类
categories: JAVA编程思想(第四版)
description: JAVA编程思想(第四版)读书笔记。
keywords: Java 
---

代码复用是Java众多引人注目的功能之一。在Java中实现代码的复用有两种方法：**组合**和**继承**。

## 1. 组合

组合只需要将对象的引用置于新类中即可，也就是在新类中定义另外一个类的引用。

## 2. 继承

继承使用`extends`关键字实现。如果想在子类中调用父类的方法，可以使用`super`关键字来实现。`super`关键字表示超类的意思。

### 2.1 初始化父类

当创建了一个子类的对象时，该对象包含了一个父类的子对象。这个子对象与你用父类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而父类的子对象被包装在子类对象内部。
注意：Java会自动在子类的构造器中插入对父类构造器的调用。

```java
class Art{
  Art(){
    System.out.println("Art constructor");
  }
}

class Drawing extends Art{
  Drawing(){
    System.out.println("Drawing constructor");
  }
}

public class Cartoon extends Drawing{
  public Cartoon(){
    System.out.println("Cartoon constructor");
  }
  public static void main(String[] args){
    Cartoon x = new Cartoon();
  }
}

输出结果：
Art constructor
Drawing constructor
Cartoon constructor
```

从输出结果可以看到，构建过程是从父类“向外”扩散的，所以父类在子类构造器可以访问它之前就已经完成了初始化。即使上例中没有显式的创建`Cartoon()`构造器，编译器也会生成一个默认的构造器，该构造器将调用父类的构造器。
需要注意的是，上例中的各个类均含有的是默认构造器，即这些构造器都不含有参数。但是，如果想要调用一个带有参数的构造器，就必须使用关键字`super`显式的编写调用父类构造器的语句，并且配以适当的参数列表。而且，调用父类构造器必须是在子类构造器中要做的第一件事。

## 3. 名称屏蔽

如果在Java中父类拥有某个已经被多次重载的方法名称，那么在子类中重新定义该方法名称并不会屏蔽骑在父类中的任何版本。

## 4. 如何在组合和继承之间选择

组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地这样做。

继承是**"is-a"**关系

组合是**"has-a"**关系

1. 组合(has-a)关系可以显式地获得被包含类（继承中称为父类）的对象，而继承(is-a)则是隐式地获得父类的对象，被包含类和父类对应，而组合外部类和子类对应。
2. 组合关系在运行期决定，而继承关系在编译期就已经决定了。
3. 组合是在组合类和被包含类之间的一种松耦合关系，而继承则是父类和子类之间的一种紧耦合关系。
4. 当选择使用组合关系时，在组合类中包含了外部类的对象，组合类可以调用外部类必须的方法，而使用继承关系时，父类的所有方法和变量都被子类无条件继承，子类不能选择。
5. 最重要的一点，使用继承关系时，可以实现类型的回溯，即用父类变量引用子类对象，这样便可以实现多态，而组合没有这个特性。
6. 还有一点需要注意，如果你确定复用另外一个类的方法永远不需要改变时，应该使用组合，因为组合只是简单地复用被包含类的接口，而继承除了复用父类的接口外，它甚至还可以覆盖这些接口，修改父类接口的默认实现，这个特性是组合所不具有的。
7. 从逻辑上看，组合最主要地体现的是一种整体和部分的思想，例如在电脑类是由内存类，CPU类，硬盘类等等组成的，而继承则体现的是一种可以回溯的父子关系，子类也是父类的一个对象。
8. 这两者的区别主要体现在类的抽象阶段，在分析类之间的关系时就应该确定是采用组合还是采用继承。
9. 引用网友的一句很经典的话应该更能让大家分清继承和组合的区别：组合可以被说成“我请了个老头在我家里干活” ，继承则是“我父亲在家里帮我干活"。

## 5. 向上转型

```java
class Instrument{
  public void play(){}
  static void tune(Instrument i){
    i.play();
  }
}
public class Wind extends Instrument{
  public static void main(String[] args){
    Wind flute = new Wind();
    Instrument.tune(flute);
  }
}
```
可以看到，在Instrument中`tune()`方法需要的参数是Instrument类型的，但是在Wind类中，`tune()`方法却传进了一个Wind类型的参数。这是因为，在`tune()`中，程序代码可以对Instrument和它所有的子类起作用，这种将Wind引用转换为Instrument引用的动作，称为**向上转型**。由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。

## 6. final关键字

### 6.1 final数据

对于基本类型，final使数值恒定不变；而对于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法把它改为指向另外一个对象。但是，对象自身是可以被修改的。一个既是static又是final的域，被称为**编译期常量**。根据惯例，编译期常量将使用大写表示，并且使用下划线分割各个单词。在Java中允许生成"空白final"，所谓的空白final是指被声明为final但又未给定初值的域。无论什么情况，编译器都确保空白final在使用之前必须被初始化。初始化方法包括在域的定义处或者在每个构造器中。

### 6.2 final方法

使用final修饰方法，可以确保在继承中使得方法行为保持不变，并且不会被覆盖。类中所有private的方法都隐式的指定为final的。

### 6.3 final类

当某个类的整体被定义为final时，就表明了你不打算继承该类，也不允许别人继承。由于final类禁止继承，所以final类中所有的方法都隐式指定为final的。



