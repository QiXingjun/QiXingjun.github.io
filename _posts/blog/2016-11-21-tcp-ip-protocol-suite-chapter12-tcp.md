---
layout: post
title: TCP/IP 协议族--传输控制协议（TCP）
categories: 计算机网络
description: 计算机网络学习总结
keywords: 计算机网路,TCP/IP,TCP
---

　　最近在学习《TCP/IP SUITE》一书，作为学习总结记录于此，也作为以后自己复习的资料。
TCP和UDP一样也是位于运输层，进程到进程的协议。但是TCP与UDP不同的是，TCP是一种面向连接的，可靠的运输层协议。此外，TCP在运输层使用流量控制和差错检测机制。下图是TCP在TCP/IP协议族中的位置：
![](http://i.imgur.com/fPmLthf.png)

## 1 TCP的服务
	
　　TCP协议为应用层的进程提供以下五种服务：

1. 进程到进程的服务
2. 流交付服务
3. 全双工通信服务
4. 面向连接服务
5. 可靠的服务

### 1.1 进程到进程的通信

　　就像UDP一样，TCP也使用端口号提供进程到进程的通信。下图是TCP使用的一些熟知的端口号：
![TCP使用的熟知端口号](http://i.imgur.com/PwB97jy.png)

### 1.2 流交付服务

　　和UDP不同，TCP是一种面向流的协议。TCP允许发送进程以字节流的形式来传递数据，接受进程把数据以字节流的形式来接收。TCP使得两个进程好像被一个假象的“管道”所连接，而这个管道在因特网上传送两个进程的数据。

#### 1.2.1 发送缓存和接收缓存

　　因为发送进程和接收进程并不会以同样的速度写入和读取数据，因此TCP需要缓存来存储数据。在每个方向都有两个缓存，即发送缓存和接收缓存。
![](http://i.imgur.com/Tdlk0tb.png)
　　在发送端，缓存有三种类型。白色部分表示空位置，发送进程可以把数据填入到空位置。深灰色部分保持一些字节，是已经发送出去但是还没有得到确认的字节。TCP会在缓存中保存这些字节，直到收到了确认。红色部分表示发送端将要发送的字节。当深灰色部分的字节被确认之后，这部分位置可以被再次的利用，这就是缓存为什么是圆形的原因。

　　在接收端，缓存被划分为两个区域。白色部分表示空位置，从网络接收的字节就填入到这个区域，红色区域表示已经接收到的字节。

#### 1.2.2 报文段

　　在发送数据之前还需要一个步骤，IP层作为TCP的服务提供者，发送数据的时候要以分组为单位，而不是按照字节流来发送。在运输层，TCP把若干字节构成一个分组，叫做报文段（segment）。TCP给每一个报文段添加首部，其中首部是为了控制的目的，然后把这个报文段交付给IP层传输。这些报文段在接收时可能会失序，丢失，或者受到损伤，所有的这些都由TCP来处理。

### 1.3 全双工通信

　　TCP提供全双工服务，所以每一个TCP都有发送缓存和接收缓存，两个方向都可以发送报文段。

### 1.4 面向连接的服务

　　和UDP不同的是，TCP提供的是面向连接的服务。通信过程：

1. 建立连接
2. 进行交换
3. 终止连接

### 1.5 可靠的服务

　　TCP是可靠的运输协议，它使用**确认机制**来检查数据是否安全和完整的到达。

## 2 TCP的特点

### 2.1 字节号，序号和确认号

　　**字节号**：TCP把在每一个方向传送的数据字节都进行编号，编号是从0~（2的32次方-1）中的一个随机产生的数开始的。例如：若随机数正好是1057，而要发送的数据总共有6000字节，那么字节号就是1057~7057。并且，在流量控制和差错控制中也要用到字节号。

　　**序号**：当字节都被编上号以后，TCP就给每一个报文段指派一个序号。每个报文段的序号就是在这个报文段中的第一个字节数据的序号。

　　**确认号**：确认号定义了这一方期望接收的下一字节的编号，此外，确认号是累计的。这表示，把正确收到的最后一个字节的编号加１所得到的和就作为确认号。这里，**累计**的含义是，如果某一方使用8888作为确认号，那么它就已经收到了一直到8888和这以前的所有字节。

### 2.2 流量控制

　　TCP提供**流量控制**：数据的接收端控制发送端可以发送多少数据，这是为了避免大量的数据使接收端瘫痪。

### 2.3 差错控制

　　虽然差错控制把一个报文段看做是差错检测的数据单元，但是差错控制是面向字节的。

### 2.4 拥塞控制

　　TCP提供在网络中的**拥塞控制**：发送端所能发送的数据量不仅仅要受到接收端的控制（流量控制），而且还要由网络的拥塞程度来决定。

## 3 报文段

　　TCP报文段的格式如下所示：
![TCP报文段](http://i.imgur.com/0RJfT7f.png)

- **源端口地址（Source port address）**：16位，定义了发送端的端口号。
- **目的端口地址（Destination port address）**：16位，定义了接收端的端口号。
- **序号（Sequence number）**：32位，指示TCP段中第一个字节的序号。建立一个新的TCP连接时（SYN标志为1），该域是主机为该连接选择的初始序号，连接建立后发送的第一个字节将具有的序号为sequence number+1。由于全双工，每个连接的端点都必须单独维持一个序号
- **确认号（Acknowledgement number）**：32位，表示发送该TCP段的主机准备从对方接收的下一个字节序号，即该序号之前的字节已全部正确收到。
- **首部长度（HLEN）**：4位，指示TCP头的长度（以4字节为单位），最大值为15（60字节）。
- **控制字段**：定义了6种不同的控制或者标志。
![控制字段各个标志位的说明](http://i.imgur.com/ZuUkJbL.png)
- **窗口值（Window size）**：16位，这个字段定义了对方必须维持的窗口值（以字节为单位）。最大长度为2的16次方。这个值通常是作为接收窗口（rwnd），并且由接收端来确定。
- **检验和（Checksum）**:16位，和UDP的检验和的过程是一样的，但是，UDP对于是否使用检验和是可选的，而TCP使用检验和则是强制的。
- **紧急指针（Urgent pointer）**：16位，只有当紧急标志置位时才有效。

## 4 TCP连接

　　TCP是面向连接的协议，它会在源点和终点建立一条虚拟路径。在TCP中，面向连接的传输需要3个阶段：连接建立，数据传输，连接终止。

### 4.1 连接建立

　　TCP以全双工的方式传送数据，TCP的连接建立叫做**三向握手** 。这个过程从服务器开始，服务器告诉它的TCP，他已经准备好接受连接，这就叫做**被动打开** 请求。客户程序发出请求**主动打开** ，打算与服务器进行连接的客户告诉它的TCP它需要连接到特定的服务。使用三向握手进行连接的建立如下图所示：
![使用三向握手建立连接](http://i.imgur.com/j7e6BYO.png)

　　三向握手的过程如下：

1. 客户发送第一个报文段，SYN报文段，在这个报文段中只有SYN标志置为1.这个报文段的作用是使序号同步。需要注意的是，这个报文段不包括确认号，也没有定义窗口值。只有当一个报文段中包含了确认时，定义窗口值才有意义。SYN报文段是一个控制报文段，它不携带任何数据，但是，它消耗一个序号。当数据开始传送时，序号就应该加1.
2. 服务器发送第二个报文段，即SYN+ACK报文段，其中有两个标志（SYN和ACK）置为1.这个报文段有两个目的：首先，它是一个用来和对方进行通信的SYN报文段。其次，服务器使用ACK标志确认已从客户端收到了SYN报文段，同时给出期望从客户端收到的下一个序号。服务器还必须定义客户端要使用的接收窗口（rwnd）。
3. 客户端发送第三个报文段，这仅仅是一个ACK报文段。它使用ACK标志和确认号字段来确认收到了第二个报文段。此时的ACK报文段如果不携带数据就不消耗序号。

　　在TCP的连接建立过程中容易碰到一个严重的安全问题，**SYN洪泛攻击** 。洪泛攻击：恶意的攻击者向一个服务器发送大量的SYN报文段，而每一个报文段来自不同的客户，并在IP数据报中使用虚假的源IP地址。服务器以为这些客户要发出主动打开，于是就分配必要的资源。如果短时间内，SYN报文段的数量很大，服务器就会因为资源耗尽而瘫痪。这种SYN洪泛攻击属于一组叫做**拒绝服务攻击** 的安全攻击。对于洪泛攻击可以采取一些策略，比如：特定时间内限定连接请求的次数；使用cookie，在整个连接没有建立之前，先不分配资源（SCTP就是采用的这种策略）。

### 4.2 数据传送

　　在连接建立之后，就可以开始数据传送了。
![数据传送](http://i.imgur.com/ihsXMt1.png)

### 4.3 连接终止

　　客户端或者服务器都可以关闭连接，当一个方向的连接被终止时，另外一方还可以继续向对方发送数据。在连接终止时，可以使用具有半关闭的三向握手或者四向握手。三向握手进行连接的终止如下图所示：
![三向握手终止连接](http://i.imgur.com/GkHTGUT.png)

1. 客户TCP收到客户进程发来的关闭命令之后，就发送第一个报文，其中包含FIN报文段。FIN可以包含客户发送的最后一块数据，如果不携带数据，FIN报文消耗一个序号。
2. 服务器TCP在接收到这个FIN报文段之后，发送包含ACK和FIN的报文段。这个报文段也可以包含从服务器发送的最后一块数据。如果它不携带数据，FIN+ACK报文段只消耗一个序号。
3. 客户端TCP发送最后一个报文段，这个报文段是一个ACK报文段，它包括确认号，确认号等于从服务器收到的FIN报文段的序号加1.

　　如果客户端发送FIN报文段，半关闭了这个连接。服务器只发送ACK报文段接收这个半关闭，但是，服务器仍然可以发送数据。当服务器已经把所有的数据都发送完毕时，才发送FIN报文段，表示对客户端的ACK进行确认。这样子就是**四向握手** 。

### 4.4 连接复位

　　在一端的TCP可以拒绝一个连接请求，可以异常终止一条连接，或者可以终止一条空闲的连接。所有的这些都可以使用复位标志（RST）来完成。

## 5 流量控制

### 5.1 流量控制

　　**流量控制** 定义了源端在收到从终点发来的确认之前可以发送的数据量。TCP使用**滑动窗口协议** 进行流量控制。滑动窗口覆盖缓存的一部分，这部分（即窗口）就是主机可以发送而不必考虑从另一个主机发来的确认。当发送出的数据得到确认时，这个窗口便在缓存上滑动。TCP的滑动窗口是面向字节的。在通信的一端，窗口的大小取决于**接收窗口（rwnd）和拥塞窗口（cwnd）**之间的较小值.

　　关于TCP滑动窗口的一些要点：

1. 窗口大小是rwnd和cwnd中较小的一个。
2. 源点并不是要发送整个窗口大小的数据。
3. 接收端可以使得窗口展开和合拢，但是不应该是它退回。
4. 终点可以在任何时刻发送确认，只要这不会引起窗口的缩回。
5. 接收端可以暂时关闭窗口，但是发送端永远可以在窗口关闭之后发送一个字节的报文段。

### 5.2 糊涂窗口综合征（SILLY WINDOW SYNDROME）

　　发送端产生数据或接收端处理数据速度很慢，使得发送的TCP报文的数据段很小，极端值：TCP发送的报文段只包括1个字节的数据，此时IP数据报长为41（20字节的IP首部＋20字节的TCP首部＋1），传输效率1/41。那该如何解决糊涂窗口综合症呢？在发送端使用**Nagle算法** ，在接收端使用**Clark算法** 。

## 6 差错控制

　　TCP使用**差错控制** 提供可靠性，差错控制包括以下的一些机制：检测受到损伤的报文段，丢失的报文段，失序的报文段，重复的报文段。差错控制还包括检测出差错之后纠正差错的机制。TCP中的差错控制和差错纠正通过如下三种机制：

- **检验和：** 每个报文段都包括检验和字段，用来检查受到损伤的报文段。
- **累计确认：** TCP采用确认来证实收到了报文段。报文段不携带数据，但是消耗一个序号，控制报文段也要被确认。ACK报文段不消耗序号，也不需要被确认。
- **超时重传：** 差错控制的核心是重传。当重传计时器的时间到，或者到达了3个重复的ACK报文段的时候，就会重传。对于ACK报文段，不设置重传计时器。

　　当一个报文段推迟到达，丢失或者被丢弃，在这个报文段后面的几个报文段就是失序到达的。如果数据不按顺序到达，接收TCP把他们暂时存储下来，但是TCP保证没有失序的报文段交付到进程。需要注意的是：**TCP只把按序的数据交付给应用进程。** 

## 7 拥塞控制

　　如果网络上的负载（发送到网络的分组数）大于网络的容量（即网络能够处理的分组数），在网络之中就可能会发生拥塞。拥塞控制是一种使网络负载低于网络容量的机制和技术。拥塞控制涉及到判断网络性能的两个因素：**延时和吞吐量** 。下图是延时和负载，吞吐量和负载的关系：
![延时和负载](http://i.imgur.com/7xaEAHH.png)

![吞吐量和负载](http://i.imgur.com/HVgcPkV.png)

### 7.1 拥塞控制机制

　　可以把拥塞控制机制分为两大类：开环拥塞控制（防止）和闭环拥塞控制（消除）。

#### 7.1.1 开环拥塞控制

　　开环拥塞控制就是在拥塞发生之前来预防拥塞。

- 重传策略
- 确认策略
- 丢弃策略

#### 7.1.2 闭环拥塞控制

　　闭环拥塞控制试图在拥塞发生之后减轻拥塞。

- 反压：当一个路由器拥塞时，它可以通知前面上游的路由器降低发送分组的速率。这个动作可以一直循环下去，知道源点前的一个路由器。
- 阻流点：阻流点是路由器向源点发出的一个分组，通知源点现在发生了拥塞。这类机制和ICMP的源点抑制分组是相似的。
- 发出隐式信号
- 发出显示信号

### 7.2 TCP中的拥塞控制

　　TCP处理拥塞的一般策略是基于三个阶段：**慢开始，拥塞避免，拥塞检测** 。在慢开始阶段，发送端从非常慢的发送速率开始，但是很快就把速率增大到一个门限。当到达门限时，数据率的增长就放慢以避免拥塞。最后，如果检测到拥塞，发送端就又回到满开始或者拥塞避免。

- **慢开始：指数增大。** 这个算法基于这样的想法,即：拥塞窗口的大小（cwnd）从一个最大报文段（MSS）开始，每当一个报文段被确认，拥塞窗口就增加一个MSS。但是，慢开始不能无限制的继续下去，发送端保持一个名为**ssthresh（慢开始门限，slow start threshold）**的变量。当窗口大小达到这个门限时，慢开始就停止，开始下一个阶段。大多数情况下的ssthresh的值为65535字节。
- **拥塞避免：加法增大。** 当拥塞窗口的大小达到慢开始门限时，慢开始阶段就停止，而加法阶段开始了。在这种算法中，每当窗口中的所有报文都被确认，拥塞窗口的大小就加1.
- **拥塞检测：乘法减小。** 如果拥塞发生了，拥塞窗口的大小就必须减小。当拥塞发生的时候，门限值就下降到**一半（即乘法减小）** 。大多数的实现对拥塞检测的反应是不一样的：（1）如果使用超时检测到拥塞，那么就开始一个新的慢开始阶段。（2）如果是用3个ACK检测到拥塞，那么就开始一个新的拥塞避免阶段。下图是一个拥塞的例子：
![拥塞的例子](http://i.imgur.com/ThOm0K9.png)
这里我们假定最大窗口值是32个报文段，门限值设为16个报文段（最大窗口值的一半）。在慢开始阶段，窗口值从1开始逐渐按照指数规律增大，直到到达窗口值的门限。在达到门限之后，**拥塞避免（加法增大）** 过程使得窗口窗口的大小按照线性规律增长，直到发生了超时，或者达到了最大窗口值。在上面这个图中，当窗口值为20时，发生了超时。这时，取代的是乘法减小的过程，并把门限减小到前面的窗口值的一半。当发生超时时，因为前面的窗口值是20，因此新的门限值是10.因为是发生超时引起的拥塞，TCP又回到慢开始，从窗口值为1开始，到达新的门限时变为加法增大。当窗口值为12时，3个ACK事件发生了。现在又转为乘法减小过程。门限值设为6，这时TCP转到加法增大阶段。




　　

